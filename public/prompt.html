<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Book Recommendations</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Playfair+Display+SC:wght@700&display=swap" rel="stylesheet">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configure Tailwind to use both Inter and Playfair Display SC fonts
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'classic-green': '#173F25',
                        'classic-cream': '#FDF9F6',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        serif: ['"Playfair Display SC"', 'serif'],
                    },
                    animation: {
                        'spin': 'spin 1s linear infinite',
                    }
                }
            }
        }
    </script>
    <style>
        
        .search-input {
            resize: none;
        }
        .search-input::-webkit-scrollbar {
            width: 4px;
        }
        .search-input::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .search-input::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 2px;
        }

        /* --- CSS for Typing Animation --- */
        @keyframes typing {
          from { width: 0; }
          to { width: 100%; }
        }

        @keyframes blink {
          50% { border-color: transparent; }
        }

        .typing-animation {
          display: inline-block;
          overflow: hidden;
          white-space: nowrap;
          border-right: 4px solid #173F25;
          animation:
            typing 3.5s steps(59, end) forwards,
            blink .75s step-end infinite;
        }

        /* --- CSS for New Search Option Buttons (Updated) --- */
        .search-option-btn {
            padding: 6px 16px;
            border-radius: 9999px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid #d1d5db; /* gray-300 */
            color: #173F25; /* classic-green */
            background-color: transparent;
        }
        .search-option-btn.active {
            background-color: #173F25; /* classic-green */
            color: #ffffff; /* white */
            border-color: #173F25;
        }
        .search-option-btn:not(.active):hover {
            border-color: #173F25;
        }

        /* --- CSS for Realistic Book Flip Animation --- */
        .book-container {
            margin: 0 auto 1.5rem;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
        }
        .book {
            width: 150px;
            height: 100px;
            position: relative;
            transform-style: preserve-3d;
            animation: open-book 3s ease-in-out infinite;
        }
        .book__page {
            width: 50%;
            height: 100%;
            position: absolute;
            top: 0;
            right: 0;
            transform-origin: left center;
            background-color: #FDF9F6;
            border: 1px solid #173F25;
            border-left: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .book__page:nth-child(1) {
            animation: flip-1 3s ease-in-out infinite;
        }
        .book__page:nth-child(2) {
            animation: flip-2 3s ease-in-out infinite;
        }
        .book__page:nth-child(3) {
            background-color: #173F25; /* This is the back cover */
            animation: flip-3 3s ease-in-out infinite;
        }
        .book::before { /* This is the static left side */
            content: '';
            width: 50%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: #FDF9F6;
            border: 1px solid #173F25;
            border-right: 1px solid #e0dccc; /* spine shadow */
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        @keyframes open-book {
            0%, 100% { transform: rotateY(0deg) rotateX(10deg); }
            20% { transform: rotateY(20deg) rotateX(10deg); }
            80% { transform: rotateY(20deg) rotateX(10deg); }
        }
        @keyframes flip-1 {
            0%, 15% { transform: rotateY(0deg); }
            40%, 80% { transform: rotateY(-180deg); }
            100% { transform: rotateY(-180deg); }
        }
        @keyframes flip-2 {
            0%, 20% { transform: rotateY(0deg); }
            45%, 80% { transform: rotateY(-180deg); }
            100% { transform: rotateY(-180deg); }
        }
        @keyframes flip-3 {
            0%, 25% { transform: rotateY(0deg); }
            50%, 80% { transform: rotateY(-180deg); }
            100% { transform: rotateY(-180deg); }
        }
    </style>
</head>
<body class="font-sans bg-classic-cream min-h-screen p-5 flex flex-col items-center justify-center">
    <div class="max-w-4xl mx-auto">
        <div class="text-center text-classic-green mb-10">
            <p class="typing-animation font-sans text-[25.7px] mb-4">
                “A Book’s True Worth is Hidden in its Wisdom, <strong class="font-bold">NOT</strong> its Cover”
            </p>
            <h2 class="font-serif text-[42.6px] font-bold uppercase tracking-widest">
                Begin by Asking...
            </h2>
        </div>

        <div class="mb-8">
            <div class="w-full bg-white border border-classic-green/30 rounded-2xl p-4 flex flex-col justify-between shadow-sm">
                <textarea
                    class="search-input w-full flex-grow bg-transparent text-classic-green placeholder-neutral-500 text-base leading-relaxed focus:outline-none"
                    id="promptInput"
                    placeholder="Ask me anything about books you'd like to read..."
                    rows="1"></textarea>
                <div class="flex items-center justify-between mt-3">
                    <div class="flex items-center space-x-2">
                        <button id="byHighlightsBtn" class="search-option-btn active">By Highlights</button>
                        <button id="bySynopsisBtn" class="search-option-btn">By Synopsis</button>
                    </div>
                    <button
                        class="send-btn flex-shrink-0 w-10 h-10 bg-neutral-100 text-neutral-400 rounded-full flex items-center justify-center transition-all duration-300 hover:bg-opacity-90 disabled:bg-neutral-100 disabled:text-neutral-300 disabled:cursor-not-allowed"
                        id="sendBtn" disabled>
                        <svg viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        <div class="loading hidden text-center text-classic-green text-lg my-5" id="loading">
            <div class="book-container">
                <div class="book">
                    <div class="book__page"></div>
                    <div class="book__page"></div>
                    <div class="book__page"></div>
                </div>
            </div>
            <p>AI is analyzing your request and finding the best book recommendations...</p>
        </div>

        <div class="results-container hidden" id="resultsContainer">
        </div>
    </div>

    <script>
        /**
         * Manages the entire book recommendation application.
         */
        class BookRecommendationSystem {
            constructor() {
                this.elements = {
                    promptInput: document.getElementById('promptInput'),
                    sendBtn: document.getElementById('sendBtn'),
                    loading: document.getElementById('loading'),
                    resultsContainer: document.getElementById('resultsContainer'),
                    byHighlightsBtn: document.getElementById('byHighlightsBtn'),
                    bySynopsisBtn: document.getElementById('bySynopsisBtn'),
                };
                this.debugMode = true;
                this.searchType = 'highlights'; // Default search type set to 'highlights'
                this.AVAILABLE_GENRES = [
                    "Habits", "Finance", "Leadership", "Mental health", "Motivational",
                    "Physical Health", "Time Management", "Communication", "Self-Discovery",
                    "Decision making", "Creativity", "Cognitive intelligence", "Behaviour",
                    "Emotional Intelligence", "Innovation", "Philosophy", "Entrepreneurship"
                ];
                this.API_BASE_URL = '';
                this.initializeEventListeners();
                this.checkServerHealth();
            }

            initializeEventListeners() {
                this.elements.sendBtn.addEventListener('click', () => this.handleSearch());
                this.elements.promptInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleSearch();
                    }
                });
                this.elements.promptInput.addEventListener('input', () => {
                    const input = this.elements.promptInput;
                    input.style.height = 'auto';
                    input.style.height = `${input.scrollHeight}px`;
                    this.elements.sendBtn.disabled = input.value.trim() === '';
                    // Update send button style based on input
                    if (input.value.trim() !== '') {
                        this.elements.sendBtn.classList.remove('bg-neutral-100', 'text-neutral-400');
                        this.elements.sendBtn.classList.add('bg-classic-green', 'text-white');
                    } else {
                        this.elements.sendBtn.classList.remove('bg-classic-green', 'text-white');
                        this.elements.sendBtn.classList.add('bg-neutral-100', 'text-neutral-400');
                    }
                });

                this.elements.byHighlightsBtn.addEventListener('click', () => {
                    this.searchType = 'highlights';
                    this.elements.byHighlightsBtn.classList.add('active');
                    this.elements.bySynopsisBtn.classList.remove('active');
                });

                this.elements.bySynopsisBtn.addEventListener('click', () => {
                    this.searchType = 'synopsis';
                    this.elements.bySynopsisBtn.classList.add('active');
                    this.elements.byHighlightsBtn.classList.remove('active');
                });
            }

            async handleSearch() {
                if (this.searchType === 'highlights') {
                    await this.handleSearchByHighlights();
                } else {
                    await this.handleSearchBySynopsis();
                }
            }

            async handleSearchBySynopsis() {
                const prompt = this.elements.promptInput.value.trim();
                if (!prompt) {
                    this.showError('Please enter a prompt to get recommendations.');
                    return;
                }

                this.showLoading(true);
                this.clearResults();

                try {
                    const langDetectionPrompt = this.generateAIPrompt('languageDetection', prompt);
                    const langResult = await this._callBackendAPI('/ai/analyze', { prompt: langDetectionPrompt });
                    const detectedLang = langResult.language || 'en';
                    this.log('Detected language:', detectedLang);

                    const genrePrompt = this.generateAIPrompt('genreAnalysis', prompt, this.AVAILABLE_GENRES.join(', '));
                    const genreResult = await this._callBackendAPI('/ai/analyze', { prompt: genrePrompt });
                    const genres = genreResult.genres || [];
                    this.log('Determined genres:', genres);
                    if (genres.length === 0) throw new Error('No relevant genres found for your query.');

                    const books = await this._callBackendAPI('/books/search-by-synopsis', { genres });
                    this.log('Found books:', books.length);
                    if (books.length === 0) throw new Error('No books found for the determined genres.');

                    const synopsisData = books.map((book, index) => `ID: synopsis_${index} | Book: "${book.title}" | Synopsis: "${book.synopsis}"`).join('\n');
                    const rankingPrompt = this.generateAIPrompt('synopsisRanking', prompt, null, synopsisData, books.length);
                    const rankingResult = await this._callBackendAPI('/ai/analyze', { prompt: rankingPrompt });
                    const selectedSynopsisIds = (rankingResult.recommendations || []).map(rec => rec.id);
                    this.log('AI selected synopsis IDs:', selectedSynopsisIds);

                    let recommendations = this._buildRecommendationsFromSynopsis(selectedSynopsisIds, books);
                    this.log('Final recommendations count:', recommendations.length);
                    if (recommendations.length === 0) throw new Error('No synopses match your query well enough.');

                    if (detectedLang === 'id' && recommendations.length > 0) {
                        recommendations = await this._translateSynopsis(recommendations);
                        this.log('Translated recommendations:', recommendations);
                    }

                    this.displayRecommendations(recommendations);

                } catch (error) {
                    this.log('Error in handleSearchBySynopsis:', error);
                    this.showError(error.message || 'An error occurred while getting recommendations.');
                } finally {
                    this.showLoading(false);
                }
            }
            
            async handleSearchByHighlights() {
                const prompt = this.elements.promptInput.value.trim();
                if (!prompt) {
                    this.showError('Please enter a prompt to get recommendations.');
                    return;
                }

                this.showLoading(true);
                this.clearResults();

                try {
                    const langDetectionPrompt = this.generateAIPrompt('languageDetection', prompt);
                    const langResult = await this._callBackendAPI('/ai/analyze', { prompt: langDetectionPrompt });
                    const detectedLang = langResult.language || 'en';
                    this.log('Detected language:', detectedLang);

                    const genrePrompt = this.generateAIPrompt('genreAnalysis', prompt, this.AVAILABLE_GENRES.join(', '));
                    const genreResult = await this._callBackendAPI('/ai/analyze', { prompt: genrePrompt });
                    const genres = genreResult.genres || [];
                    this.log('Determined genres:', genres);
                    if (genres.length === 0) throw new Error('No relevant genres found for your query.');

                    const books = await this._callBackendAPI('/books/search', { genres });
                    this.log('Found books:', books.length);
                    if (books.length === 0) throw new Error('No books found for the determined genres.');

                    const allHighlights = this._extractAllHighlights(books);
                    this.log('Total extracted highlights:', allHighlights.length);
                    if (allHighlights.length === 0) throw new Error('No valid highlights found in the books.');

                    const highlightData = allHighlights.map(h => `ID: ${h.id} | Book: "${h.bookTitle}" | Highlight: "${h.text}"`).join('\n');
                    const rankingPrompt = this.generateAIPrompt('highlightRanking', prompt, null, highlightData, allHighlights.length);
                    const rankingResult = await this._callBackendAPI('/ai/analyze', { prompt: rankingPrompt });
                    const selectedHighlightIds = (rankingResult.recommendations || []).map(rec => rec.id);
                    this.log('AI selected highlight IDs:', selectedHighlightIds);

                    let recommendations = this._buildRecommendations(selectedHighlightIds, allHighlights);
                    this.log('Final recommendations count:', recommendations.length);
                    if (recommendations.length === 0) throw new Error('No highlights match your query well enough.');

                    if (detectedLang === 'id' && recommendations.length > 0) {
                        recommendations = await this._translateHighlights(recommendations);
                        this.log('Translated recommendations:', recommendations);
                    }

                    this.displayRecommendations(recommendations);

                } catch (error) {
                    this.log('Error in handleSearch:', error);
                    this.showError(error.message || 'An error occurred while getting recommendations.');
                } finally {
                    this.showLoading(false);
                }
            }
            
            async _translateSynopsis(recommendations) {
                const synopsisToTranslate = recommendations.map(rec => rec.highlight); // reusing highlight property
                const translationPrompt = this.generateAIPrompt('highlightTranslation', null, null, synopsisToTranslate);
                const translationResult = await this._callBackendAPI('/ai/analyze', { prompt: translationPrompt });

                if (!translationResult.translations || translationResult.translations.length !== recommendations.length) {
                    this.log('Translation failed or returned mismatched count.');
                    return recommendations; // Fallback to English if translation fails
                }

                return recommendations.map((rec, index) => {
                    const translatedText = translationResult.translations[index];
                    return {
                        ...rec,
                        highlight: translatedText || rec.highlight // Use translated text or fallback to original
                    };
                });
            }

            async _translateHighlights(recommendations) {
                const highlightsToTranslate = recommendations.map(rec => rec.highlight);
                const translationPrompt = this.generateAIPrompt('highlightTranslation', null, null, highlightsToTranslate);
                const translationResult = await this._callBackendAPI('/ai/analyze', { prompt: translationPrompt });

                if (!translationResult.translations || translationResult.translations.length !== recommendations.length) {
                    this.log('Translation failed or returned mismatched count.');
                    return recommendations; // Fallback to English if translation fails
                }

                return recommendations.map((rec, index) => {
                    const translatedText = translationResult.translations[index];
                    return {
                        ...rec,
                        highlight: translatedText || rec.highlight // Use translated text or fallback to original
                    };
                });
            }

            displayRecommendations(recommendations) {
                if (!recommendations || recommendations.length === 0) {
                    this.showError('No relevant highlights found that match your query.');
                    return;
                }
                const recommendationsHTML = recommendations
                    .map((rec, index) => this._createRecommendationHTML(rec, index))
                    .join('');
                this.elements.resultsContainer.innerHTML = recommendationsHTML;
                this.elements.resultsContainer.style.display = 'block';
            }

            _createRecommendationHTML(rec, index) {
                const { title, author, highlight } = rec;
                return `
                    <div class="bg-white rounded-2xl p-6 mb-5 shadow-lg border-l-4 border-classic-green transition-transform duration-300 hover:-translate-y-1 hover:shadow-xl relative">
                        <div class="absolute top-4 right-4 bg-classic-green text-white text-xs px-2 py-1 rounded-full font-semibold">
                            #${index + 1} Best Match
                        </div>
                        <div class="text-base leading-relaxed text-neutral-800 bg-neutral-100 p-4 rounded-lg border-l-4 border-neutral-400 italic mb-4 pr-20">"${this.escapeHtml(highlight)}"</div>
                        <div class="text-xl font-bold text-classic-green mb-2">${this.escapeHtml(title)}</div>
                        <div class="text-base text-neutral-600 italic">by ${this.escapeHtml(author)}</div>
                    </div>
                `;
            }

            showLoading(show) {
                this.elements.loading.style.display = show ? 'block' : 'none';
                this.elements.sendBtn.disabled = show;
            }

            clearResults() {
                this.elements.resultsContainer.style.display = 'none';
                this.elements.resultsContainer.innerHTML = '';
                document.querySelectorAll('.error-message').forEach(el => el.remove());
            }

            showError(message) {
                this.clearResults();
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message bg-classic-green bg-opacity-10 border border-classic-green text-classic-green p-4 rounded-lg my-5 text-center';
                errorDiv.textContent = message;
                this.elements.resultsContainer.parentNode.insertBefore(errorDiv, this.elements.resultsContainer);
                this.log('Error displayed:', message);
            }

            _extractAllHighlights(books) {
                const allHighlights = [];
                books.forEach((book, bookIndex) => {
                    const highlights = this._parseHighlights(book.highlights);
                    highlights.forEach((highlight, highlightIndex) => {
                        allHighlights.push({
                            id: `highlight_${bookIndex}_${highlightIndex}`,
                            text: highlight,
                            bookTitle: book.title,
                            bookAuthor: book.author
                        });
                    });
                });
                return allHighlights;
            }

            _buildRecommendations(selectedIds, allHighlights) {
                const recommendations = [];
                for (const id of selectedIds) {
                    const highlight = allHighlights.find(h => h.id === id);
                    if (highlight) {
                        recommendations.push({
                            title: highlight.bookTitle,
                            author: highlight.bookAuthor,
                            highlight: highlight.text
                        });
                    }
                }
                return recommendations;
            }
            
            _buildRecommendationsFromSynopsis(selectedIds, books) {
                const recommendations = [];
                for (const id of selectedIds) {
                    const index = parseInt(id.split('_')[1]);
                    const book = books[index];
                    if (book) {
                        recommendations.push({
                            title: book.title,
                            author: book.author,
                            highlight: book.synopsis
                        });
                    }
                }
                return recommendations;
            }

            async _callBackendAPI(endpoint, data, method = 'POST') {
                try {
                    this.log(`Calling backend API: ${endpoint}`, { data, method });
                    const config = {
                        method: method,
                        headers: { 'Content-Type': 'application/json' },
                    };
                    if (method !== 'GET') {
                        config.body = JSON.stringify(data);
                    }
                    const response = await fetch(`${this.API_BASE_URL}/api${endpoint}`, config);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `API error (${response.status})`);
                    }
                    return await response.json();
                } catch (error) {
                    this.log('Backend API call failed:', error);
                    throw new Error(`Backend API call failed: ${error.message}`);
                }
            }

            async checkServerHealth() {
                try {
                    const health = await this._callBackendAPI('/health', null, 'GET');
                    this.log('Server health check:', health);
                    if (!health.env.hasGroqKey || !health.env.hasSupabaseUrl || !health.env.hasSupabaseKey) {
                        this.showError('Server configuration incomplete.');
                    }
                } catch (error) {
                    this.showError('Cannot connect to backend server.');
                }
            }

            _parseHighlights(highlightsText) {
                if (!highlightsText || typeof highlightsText !== 'string') return [];
                const regex = /(["“])(.*?)(["”])/g;
                const matches = [...highlightsText.matchAll(regex)];
                if (matches.length > 0) {
                    return matches.map(match => match[2].trim());
                }
                const singleHighlight = highlightsText.trim();
                return singleHighlight ? [singleHighlight] : [];
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            log(message, data = null) {
                if (this.debugMode) console.log(`[DEBUG] ${message}`, data || '');
            }

            generateAIPrompt(taskType, userPrompt, availableGenres = null, highlightData = null, totalCount = 0) {
                const prompts = {
                    languageDetection: {
                        role: "You are a highly accurate language identification AI.",
                        task: "Analyze the user's query and determine if it is primarily written in English or Indonesian.",
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "language".
- The value must be either "en" for English or "id" for Indonesian.
- Example for Indonesian: {"language": "id"}
- Example for English: {"language": "en"}
- Do NOT include any other text or explanations.`,
                        content: `User query: "${userPrompt}"`
                    },
                    highlightTranslation: {
                        role: "You are an expert translator specializing in conveying the nuanced meaning of book highlights from English to Indonesian.",
                        task: "Translate EACH of the following English book highlights into Indonesian. Preserve the core wisdom, context, and tone of the original highlight. Return the translations in the exact same order as the input.",
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "translations".
- The value must be an array of strings.
- Each string in the array must be the Indonesian translation of the corresponding highlight.
- The order of the translated strings must match the order of the original highlights.
- Example: {"translations": ["Terjemahan pertama.", "Terjemahan kedua."]}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `Original English highlights (JSON array format):\n${JSON.stringify(highlightData)}`
                    },
                    genreAnalysis: {
                        role: "You are a specialized AI assistant with expert knowledge of book genres and user intent analysis. You are fluent in both English and Indonesian.",
                        context: `Available genres: ${availableGenres}`,
                        task: `Analyze the user's query, which can be in English or Indonesian, and determine which book genres would be most relevant.`,
                        process: `
1. First, detect the language of the user's query (English or Indonesian).
2. Carefully read the query to understand the user's needs, interests, or preferences, regardless of the language.
3. Scan the available genres for the best matches based on the query's meaning.
4. Prioritize genres where the benefits directly address the user's query.
5. Select a minimum of 1 and a maximum of 3 genres that are most relevant.
6. If the query is vague, choose the most general applicable genres.`,
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "genres".
- The value of "genres" must be an array of strings.
- Each string must be the exact "Name" of a recommended genre from the provided list.
- Example: {"genres": ["Mental health", "Habits", "Leadership"]}
- If no matches: {"genres": []}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `User query: "${userPrompt}"\n\nSelected genres:`
                    },
                    highlightRanking: {
                        role: "You are an expert content analyst specializing in matching book insights to user queries with surgical precision. You are fluent in both English and Indonesian.",
                        context: `You have ${totalCount} individual book highlights. Your task is to find the most relevant highlights that directly answer or address the user's specific query, which may be in English or Indonesian.`,
                        task: `Select the TOP 5 most relevant highlights that best answer the user's query. The user's query can be in English or Indonesian.`,
                        process: `
1. Analyze the user's query, whether it is in English or Indonesian, to identify their specific need, problem, or area of interest.
2. Evaluate each highlight for direct relevance to the query's meaning. How well does it answer or address what the user is asking?
3. Score each highlight: HIGH (directly answers query), MEDIUM (related/helpful), LOW (tangentially related).
4. Select only HIGH and strong MEDIUM scoring highlights.
5. Rank the selected highlights by relevance score (best matches first).
6. It's acceptable to select multiple highlights from the same book if they're all highly relevant.
7. Never select duplicate/identical highlights.
8. A maximum of 5 highlights is allowed, but fewer is acceptable if only a few are truly relevant.`,
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "recommendations".
- The value must be an array of objects, each with an "id" field.
- Each "id" must match exactly one of the highlight IDs provided.
- Order by relevance (best match first).
- Example: {"recommendations": [{"id": "highlight_3"}, {"id": "highlight_7"}, {"id": "highlight_1"}]}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `Available highlights:\n${highlightData}\n\nUser query: "${userPrompt}"\n\nBest matching highlights (ranked by relevance):`
                    },
                    synopsisRanking: {
                        role: "You are an expert content analyst specializing in matching book synopses to user queries with surgical precision. You are fluent in both English and Indonesian.",
                        context: `You have ${totalCount} individual book synopses. Your task is to find the most relevant synopses that directly answer or address the user's specific query, which may be in English or Indonesian.`,
                        task: `Select the TOP 5 most relevant synopses that best answer the user's query. The user's query can be in English or Indonesian.`,
                        process: `
1. Analyze the user's query, whether it is in English or Indonesian, to identify their specific need, problem, or area of interest.
2. Evaluate each synopsis for direct relevance to the query's meaning. How well does it answer or address what the user is asking?
3. Score each synopsis: HIGH (directly answers query), MEDIUM (related/helpful), LOW (tangentially related).
4. Select only HIGH and strong MEDIUM scoring synopses.
5. Rank the selected synopses by relevance score (best matches first).
6. It's acceptable to select multiple synopses from the same book if they're all highly relevant.
7. Never select duplicate/identical synopses.
8. A maximum of 5 synopses is allowed, but fewer is acceptable if only a few are truly relevant.`,
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "recommendations".
- The value must be an array of objects, each with an "id" field.
- Each "id" must match exactly one of the synopsis IDs provided.
- Order by relevance (best match first).
- Example: {"recommendations": [{"id": "synopsis_3"}, {"id": "synopsis_7"}, {"id": "synopsis_1"}]}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `Available synopses:\n${highlightData}\n\nUser query: "${userPrompt}"\n\nBest matching synopses (ranked by relevance):`
                    }
                };
                const selectedPrompt = prompts[taskType];
                if (!selectedPrompt) throw new Error(`Unknown task type: ${taskType}`);

                let promptString = `# ROLE\n${selectedPrompt.role}`;
                if (selectedPrompt.context) promptString += `\n\n# CONTEXT\n${selectedPrompt.context}`;
                if (selectedPrompt.task) promptString += `\n\n# TASK\n${selectedPrompt.task}`;
                if (selectedPrompt.process) promptString += `\n\n# PROCESS\n${selectedPrompt.process}`;
                if (selectedPrompt.outputFormat) promptString += `\n\n# OUTPUT FORMAT\n${selectedPrompt.outputFormat}`;
                if (selectedPrompt.content) promptString += `\n\n${selectedPrompt.content}`;

                return promptString;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing Book Recommendation System...');
            new BookRecommendationSystem();

            const typingElement = document.querySelector('.typing-animation');

            typingElement.addEventListener('animationend', (event) => {
                if (event.animationName === 'typing') {
                    typingElement.style.borderRightColor = 'transparent';
                }
            });

            // --- New code for search option toggle ---
            const byHighlightsBtn = document.getElementById('byHighlightsBtn');
            const bySynopsisBtn = document.getElementById('bySynopsisBtn');
            const optionBtns = [byHighlightsBtn, bySynopsisBtn];

            optionBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active class from all buttons
                    optionBtns.forEach(b => b.classList.remove('active'));
                    // Add active class to the clicked button
                    btn.classList.add('active');
                });
            });
            // --- End of new code ---
        });
    </script>
</body>
</html>